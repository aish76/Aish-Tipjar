@@ -1,257 +1,9 @@
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketPlaceService = game:GetService("MarketplaceService")
local TweenService = game:GetService("TweenService")
local textService = game:GetService("TextService")
local MessagingService = game:GetService("MessagingService")
--[[

local jarEffectModule = require(script.JarEffects)
local JarInitialize = require(script.JarInitialize)
local GlobalMessage = require(script.JarGlobalMessages)
local Webhook = require(script.JarWebhook)
local Utilities = require(script.JarUtilities)
local bannedGamepassAsset = require(script.JarBannedGamepassId)
local jarTools = require(script.JarToolHandler)
local cacheData = require(script.Parent.CacheData)
▒█░▒█ ▒█▄░▒█ ▒█▀▀▀█ ▒█▀▀▀█ ▀█▀ ▒█▀▀▀█ ▒█▀▀▀ 
▒█░▒█ ▒█▒█▒█ ▒█░░▒█ ░▀▀▀▄▄ ▒█░ ░▄▄▄▀▀ ▒█▀▀▀ 
░▀▄▄▀ ▒█░░▀█ ▒█▄▄▄█ ▒█▄▄▄█ ▄█▄ ▒█▄▄▄█ ▒█▄▄▄

local Compression = require(ReplicatedStorage.Modules.Compression)
local AssetHandler = require(script.Parent.AssetHandler)
]]--

local jarTextRemote = ReplicatedStorage.UnoStudio.UpdateJarText
local sendMessageRemote = ReplicatedStorage.UnoStudio.SendMessage
local purchaseRemote = ReplicatedStorage.UnoStudio.Jar.PurchaseDonation

local jarCore = {}

jarCore.onGoingTransaction = {}
jarCore.priceVerificationAttempts = 3 
jarCore.priceVerificationDelay = 1 

function jarCore:Init()
	local startTime = os.clock()

	GlobalMessage:ListenToGlobalMessage()
	JarInitialize:setupPlayer()
	jarTools:listenToEvents()
	jarCore:setupConnection()

	local deltaTime = os.clock() - startTime
end

function jarCore:setupConnection()
	MarketPlaceService.PromptGamePassPurchaseFinished:Connect(function(player: Player, assetId: number, purchased)
		if not purchased then
			if self.onGoingTransaction[player.UserId] then
				self.onGoingTransaction[player.UserId] = nil
			end
			return
		end
		if table.find(bannedGamepassAsset, assetId) then return end
		sendMessageRemote:FireClient(player, "Please wait, Verifying your donation.")

		local success, currentInfo = pcall(function()
			return MarketPlaceService:GetProductInfo(assetId, Enum.InfoType.GamePass)
		end)

		if not success or not currentInfo then
			sendMessageRemote:FireClient(player, "Failed to verify the gamepass info. Roblox API issue.")
			return 
		end

		local RecipentUserId = currentInfo.Creator.Id

		local priceConsistent, verifiedPrice = self:verifyPriceConsistency(player, assetId)
		if not priceConsistent then
			sendMessageRemote:FireClient(player, "Donation verification failed. Gamepass price changed during transaction.")
			return
		end

		local joinTimeCheckPassed = self:verifyJoinTime(player, currentInfo)
		if not joinTimeCheckPassed then
			return
		end

		local transaction = self.onGoingTransaction[player.UserId]
		local RealAmount = transaction and transaction.assetPrice or verifiedPrice

		self:handleVerifiedPurchase(player, RecipentUserId, RealAmount, currentInfo, assetId)
	end)

	jarTextRemote.OnServerEvent:Connect(function(player, newText)
		local character = player.Character
		if character then
			local tool = character:FindFirstChild("TipMePls")
			if tool then
				local handle = tool:FindFirstChild("Handle")
				if handle then
					local textbillboard = handle:FindFirstChild("Textbillboard")
					if textbillboard then
						local textresult = textbillboard:FindFirstChild("TextLabel")
						if textresult then
							local success, filteredText = pcall(function()
								return textService:FilterStringAsync(newText, player.UserId):GetNonChatStringForBroadcastAsync()
							end)

							if success then
								textresult.Text = filteredText
							else
								textresult.Text = "Please Avoid Bad Words!"
							end
						end
					end
				end
			end
		end
	end)

	purchaseRemote.OnServerEvent:Connect(function(player: Player, assetId: number)
		if self.onGoingTransaction[player.UserId] then
			return
		end

		-- Get initial gamepass info
		local success, info = pcall(function()
			return MarketPlaceService:GetProductInfo(assetId, Enum.InfoType.GamePass)
		end)

		if not success or not info then
			sendMessageRemote:FireClient(player, "Failed to get gamepass information. Please try again.")
			return
		end

		local priceConsistent = self:checkInitialPriceConsistency(player, assetId, info.PriceInRobux)
		if not priceConsistent then
			sendMessageRemote:FireClient(player, "Gamepass price is unstable. Please try again later.")
			return
		end

		local assetCreatorId = info.Creator.Id
		local price = info.PriceInRobux
		local assetCreatorJoinTime = cacheData.getPlayerJoinTime(info.Creator.Id)

		if not assetCreatorId or not price or not assetCreatorJoinTime then
			warn("[Transaction Skipped] Missing asset info for", player, assetId, assetCreatorId, price, assetCreatorJoinTime)
			return 
		end

		self.onGoingTransaction[player.UserId] = {
			assetOwnerId = assetCreatorId,
			assetPrice = price,  
			assetCreatorJoin = assetCreatorJoinTime,
			assetId = assetId,
			verificationTime = os.time()
		}

		MarketPlaceService:PromptGamePassPurchase(player, assetId)
	end)
end


function jarCore:checkInitialPriceConsistency(player: Player, assetId: number, initialPrice: number)
	for i = 1, self.priceVerificationAttempts do
		task.wait(self.priceVerificationDelay)

		local success, currentInfo = pcall(function()
			return MarketPlaceService:GetProductInfo(assetId, Enum.InfoType.GamePass)
		end)

		if not success or not currentInfo then
			return false
		end

		if currentInfo.PriceInRobux ~= initialPrice then
			return false
		end
	end

	return true
end

function jarCore:verifyPriceConsistency(player: Player, assetId: number)
	local userId = player.UserId
	local transaction = self.onGoingTransaction[userId]

	if not transaction then
		return false, nil
	end

	local expectedPrice = transaction.assetPrice
